"""
Generates the C placeholder for the external numerical interpolation engine.

This module registers a 'placeholder' interpolation engine that mimics the
batch-processing API of a numerical integrator. Instead of performing
actual interpolation, it calls the exact analytic C functions for the
specified spacetime.

Author: Dalton J. Moone
"""

import nrpy.c_function as cfc


def placeholder_interpolation_engine(spacetime_name: str, PARTICLE: str) -> None:
    """
    Generate and register the high-fidelity C placeholder interpolation engine.

    This function generates a C function named 'placeholder_interpolation_engine_{spacetime_name}'.
    It serves as a stand-in for a future, high-performance numerical interpolation library.
    It mimics the required batch-processing API but computes the metric and Christoffel symbols
    by calling the existing, trusted analytic C worker functions:
      - g4DD_metric_{spacetime_name}
      - connections_{spacetime_name}

    :param spacetime_name: Name of the spacetime (e.g., "KerrSchild").
    :param PARTICLE: The type of particle ("massive" or "photon").
                     Determines array size for the state vector f.
    :raises ValueError: If PARTICLE is not "massive" or "photon".
    """
    # Step 1: Specific setup based on particle type
    if PARTICLE == "massive":
        array_size = 8
    elif PARTICLE == "photon":
        array_size = 9
    else:
        raise ValueError(f"Unsupported PARTICLE: {PARTICLE}")

    # Step 2: Define C function metadata
    # We need BHaH_function_prototypes.h to know the signatures of the worker functions
    includes = ["BHaH_defines.h", "BHaH_function_prototypes.h"]
    
    desc = f"""@brief Placeholder for the external batch-processing interpolation engine.

    ========================================================================
    ================== THIS IS A VALIDATION PLACEHOLDER ==================
    Spacetime: {spacetime_name}
    Particle:  {PARTICLE}
    ========================================================================

    It mimics the required API but computes the metric and Christoffel symbols
    by calling the low-level ANALYTIC WORKER functions directly. This provides
    a ground-truth analytic result for validating the numerical control flow.
    """
    
    name = f"placeholder_interpolation_engine_{spacetime_name}"
    
    params = """const commondata_struct *restrict commondata,
                const int num_photons,
                const photon_request_t *restrict requests,
                metric_struct *restrict metric_outputs,
                connection_struct *restrict conn_outputs"""

    # Step 3: Generate C Body
    # We construct the function calls dynamically based on the spacetime name.
    # These match the functions registered in g4DD_metric.py and connections.py
    metric_worker_func = f"g4DD_metric_{spacetime_name}"
    conn_worker_func = f"connections_{spacetime_name}"

    body = f"""
    // This function loops through each request and computes the metric and
    // Christoffels individually by calling the specific analytic workers.
    #pragma omp parallel for
    for (int i = 0; i < num_photons; ++i) {{
        // The analytic worker functions expect a state vector 'f' of size {array_size}.
        // We create a temporary array on the stack for this thread.
        double f[{array_size}];

        // Unpack the position from the request struct.
        // photon_request_t is defined in BHaH_defines.h
        f[0] = requests[i].pos[0]; // t
        f[1] = requests[i].pos[1]; // x
        f[2] = requests[i].pos[2]; // y
        f[3] = requests[i].pos[3]; // z

        // Initialize remaining components to 0 (momentum/param not used for metric/conn)
        // This prevents uninitialized value warnings.
        for (int j = 4; j < {array_size}; j++) {{
            f[j] = 0.0;
        }}
        // Call the specific analytic worker functions.
        // These signatures match the ones generated by g4DD_metric.py and connections.py.
        {metric_worker_func}(commondata, f, &metric_outputs[i]);

        // Compute connections only if a valid pointer was passed
        if (conn_outputs != NULL) {{
            {conn_worker_func}(commondata, f, &conn_outputs[i]);
        }}
    }}
    """

    # Step 4: Register the C function
    cfc.register_CFunction(
        includes=includes,
        desc=desc,
        name=name,
        params=params,
        body=body,
    )


if __name__ == "__main__":
    import logging
    import os
    import sys

    # Ensure local modules can be imported
    sys.path.append(os.getcwd())

    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("TestPlaceholderInterpolationEngine")

    SPACETIME = "KerrSchild_Cartesian"
    PARTICLE = "photon"

    logger.info("Test: Generating Placeholder Interpolation Engine C-code for %s (%s)...", SPACETIME, PARTICLE)

    try:
        # 1. Run the Generator
        logger.info(" -> Calling placeholder_interpolation_engine()...")
        placeholder_interpolation_engine(SPACETIME, PARTICLE)

        # 2. Validation
        cfunc_name = f"placeholder_interpolation_engine_{SPACETIME}"

        # Check C Function Registration
        if cfunc_name not in cfc.CFunction_dict:
            raise RuntimeError(
                f"FAIL: '{cfunc_name}' was not registered in cfc.CFunction_dict."
            )

        logger.info(" -> PASS: '%s' function registered successfully.", cfunc_name)

        # 3. Output Files to Current Directory
        for func_name, c_function in cfc.CFunction_dict.items():
            filename = f"{func_name}.c"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(c_function.full_function)
            logger.info("    ... Wrote %s", filename)

        logger.info(" -> Success! C function generated.")

    except Exception as e:
        logger.error(" -> FAIL: placeholder_interpolation_engine test failed with error: %s", e)
        import traceback
        traceback.print_exc()
        sys.exit(1)