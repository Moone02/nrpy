"""
Generates the C placeholder for the external numerical interpolation engine.

Author: Dalton J. Moone
"""

import nrpy.c_function as cfc

def placeholder_interpolation_engine(spacetime_name: str, PARTICLE: str) -> None:
    if PARTICLE == "massive":
        array_size = 8
    elif PARTICLE == "photon":
        array_size = 9
    else:
        raise ValueError(f"Unsupported PARTICLE: {PARTICLE}")

    includes = ["BHaH_defines.h", "BHaH_function_prototypes.h"]

    desc = f"""@brief Placeholder for the external batch-processing interpolation engine.
    Adapted for flattened SoA arrays. Passes the global batch capacity stride
    to underlying analytic workers.
    """

    name = f"placeholder_interpolation_engine_{spacetime_name}"
    params = """const commondata_struct *restrict commondata,
                const int num_photons,
                const int *restrict req_photon_ids,
                const double *restrict req_pos,
                double *restrict metric_g4DD,
                double *restrict conn_GammaUDD"""

    metric_worker_func = f"g4DD_metric_{spacetime_name}"
    conn_worker_func = f"connections_{spacetime_name}"

    body = f"""
    #pragma omp parallel for
    for (int batch_id = 0; batch_id < num_photons; ++batch_id) {{
        double f_local[{array_size}];
        double local_metric[10];
        double local_conn[40];
        
        // Populate local state
        for (int m = 0; m < 4; m++) {{
            f_local[m] = req_pos[IDX_LOCAL(m, batch_id, BUNDLE_CAPACITY)];
        }}
        for (int j = 4; j < {array_size}; j++) {{
            f_local[j] = 0.0;
        }}

        // Analytic engines now output to local 1D arrays
        {metric_worker_func}(commondata, f_local, local_metric, 1, 0);

        // Explicitly write the metric components to the batch array using IDX_LOCAL
        for (int i = 0; i < 10; i++) {{
            metric_g4DD[IDX_LOCAL(i, batch_id, BUNDLE_CAPACITY)] = local_metric[i];
        }}

        if (conn_GammaUDD != NULL) {{
            {conn_worker_func}(commondata, f_local, local_conn, 1 ,0);
            
            // Explicitly write connection components to the batch array using IDX_LOCAL
            for (int i = 0; i < 40; i++) {{
                conn_GammaUDD[IDX_LOCAL(i, batch_id, BUNDLE_CAPACITY)] = local_conn[i];
            }}
        }}
    }}
    """

    cfc.register_CFunction(
        includes=includes, desc=desc, name=name, params=params, body=body,
    )

if __name__ == "__main__":
    import logging
    import os
    import sys
    sys.path.append(os.getcwd())
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("TestPlaceholderInterpolationEngine")
    SPACETIME = "KerrSchild_Cartesian"
    PARTICLE = "photon"
    logger.info("Test: Generating Placeholder Interpolation Engine C-code...")
    try:
        placeholder_interpolation_engine(SPACETIME, PARTICLE)
        for func_name, c_function in cfc.CFunction_dict.items():
            filename = f"{func_name}.c"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(c_function.full_function)
    except Exception as e:
        logger.error(" -> FAIL: placeholder_interpolation test failed: %s", e)
        sys.exit(1)
